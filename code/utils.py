import json
import warnings
from pathlib import Path
from typing import Union, List, Optional, Literal
import numpy as np

import pynwb

from spikeinterface import BaseRecording, SortingAnalyzer


def add_waveforms_with_uneven_channels(
    sorting_analyzer: SortingAnalyzer,
    recording: BaseRecording = None,
    nwbfile: Optional[pynwb.NWBFile] = None,
    metadata: Optional[dict] = None,
    unit_ids: Optional[List[Union[str, int]]] = None,
    skip_properties: Optional[List[str]] = None,
    property_descriptions: Optional[dict] = None,
    write_as: Literal["units", "processing"] = "units",
    units_name: str = "units",
    units_description: str = "Autogenerated by neuroconv.",
    write_waveforms: bool = True,
):
    """
    Modified version of the neurconv.tools.spikeinterface.add_waveforms function
    to deal with multiple streams with an uneven number of channels (due to bad channel removel).
    The strategy is to add electrodes using the "full" recording and pad missing waveform channels
    with zeros.
    """
    from neuroconv.tools.spikeinterface.spikeinterface import (
        add_electrodes_info_to_nwbfile,
        add_units_table_to_nwbfile,
        _get_electrode_group_indices,
    )

    # TODO: move into add_units
    assert write_as in [
        "units",
        "processing",
    ], f"Argument write_as ({write_as}) should be one of 'units' or 'processing'!"
    if write_as == "units":
        assert units_name == "units", "When writing to the nwbfile.units table, the name of the table must be 'units'!"
    write_in_processing_module = False if write_as == "units" else True

    num_units = len(sorting_analyzer.unit_ids)
    sorting = sorting_analyzer.sorting

    # pad with zeros if needed
    if write_waveforms:
        template_ext = sorting_analyzer.get_extension("templates")
        if recording.get_num_channels() >= sorting_analyzer.get_num_channels():
            template_means_partial = template_ext.get_templates()
            template_stds_partial = template_ext.get_templates(operator="std")
            num_samples = template_means_partial.shape[1]
            template_means = np.zeros((num_units, num_samples, recording.get_num_channels()))
            template_stds = np.zeros((num_units, num_samples, recording.get_num_channels()))
            channel_mask = np.isin(recording.channel_ids, sorting_analyzer.channel_ids)
            template_means[:, :, channel_mask] = template_means_partial
            template_stds[:, :, channel_mask] = template_stds_partial
        else:
            template_means = template_ext.get_templates()
            template_stds = template_ext.get_templates(operator="std")

        if unit_ids is not None:
            unit_indices = sorting.ids_to_indices(unit_ids)
            template_means = template_means[unit_indices]
            template_stds = template_stds[unit_indices]
    else:
        template_means = None
        template_stds = None
        unit_electrode_indices = None

    # metrics properties (quality, template) are added as properties to the sorting copy
    sorting_copy = sorting.select_units(unit_ids=sorting.unit_ids)
    if sorting_analyzer.has_extension("quality_metrics"):
        qm = sorting_analyzer.get_extension("quality_metrics").get_data()
        for prop in qm.columns:
            if prop not in sorting_copy.get_property_keys():
                sorting_copy.set_property(prop, qm[prop])
    if sorting_analyzer.has_extension("template_metrics"):
        tm = sorting_analyzer.get_extension("template_metrics").get_data()
        for prop in tm.columns:
            if prop not in sorting_copy.get_property_keys():
                sorting_copy.set_property(prop, tm[prop])

    # add electrodes only if needed
    if nwbfile.electrodes is None and write_waveforms:
        add_electrodes_info_to_nwbfile(recording, nwbfile=nwbfile, metadata=metadata)
    electrode_group_indices = _get_electrode_group_indices(recording, nwbfile=nwbfile)

    available_nwb_groups = np.unique(nwbfile.electrodes["group_name"][:])
    available_recording_groups = np.unique(recording.get_channel_groups())

    if write_waveforms:
        if len(electrode_group_indices) == 0:
            print(
                f"Could not find electrode group indices for templates: waveform_mean/sd will not be added to NWB.\n"
                f"Groups in NWB: {available_nwb_groups} - Groups in recording: {available_recording_groups}."
            )
            template_means = None
            template_stds = None
            unit_electrode_indices = None
        else:
            unit_electrode_indices = [electrode_group_indices] * num_units        

    add_units_table_to_nwbfile(
        sorting=sorting_copy,
        nwbfile=nwbfile,
        unit_ids=unit_ids,
        property_descriptions=property_descriptions,
        skip_properties=skip_properties,
        write_in_processing_module=write_in_processing_module,
        units_table_name=units_name,
        unit_table_description=units_description,
        waveform_means=template_means,
        waveform_sds=template_stds,
        unit_electrode_indices=unit_electrode_indices,
    )
